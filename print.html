<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python для Рины</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_00_intro.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="00_01_algorithms.html"><strong aria-hidden="true">1.1.</strong> Алгоритмы</a></li><li class="chapter-item expanded "><a href="00_02_computer.html"><strong aria-hidden="true">1.2.</strong> Как работают компьютеры</a></li><li class="chapter-item expanded "><a href="00_03_abstractions_and_vms.html"><strong aria-hidden="true">1.3.</strong> Абстракции и виртуальные машины</a></li><li class="chapter-item expanded "><a href="00_04_languages_and_levels.html"><strong aria-hidden="true">1.4.</strong> Языки программирования</a></li></ol></li><li class="chapter-item expanded "><a href="01_00_game.html"><strong aria-hidden="true">2.</strong> Давай сыграем в игру</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_01_ipython_look.html"><strong aria-hidden="true">2.1.</strong> Как выглядит IPython</a></li><li class="chapter-item expanded "><a href="01_02_print.html"><strong aria-hidden="true">2.2.</strong> Вывод текста</a></li><li class="chapter-item expanded "><a href="01_03_calc_on_steroids.html"><strong aria-hidden="true">2.3.</strong> IPython - калькулятор на стероидах</a></li><li class="chapter-item expanded "><a href="01_04_types.html"><strong aria-hidden="true">2.4.</strong> Типы данных</a></li><li class="chapter-item expanded "><a href="01_05_variables.html"><strong aria-hidden="true">2.5.</strong> Переменные</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python для Рины</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<p>В этом разделе изложены вещи, которые нужно знать любому человеку, занимающемуся программированием.</p>
<p>В главе “Алгоритмы” рассказывается о самом важном понятии в программировании. </p>
<p>В главе “Как работают компьютеры” приведено до предела упрощённое описание внутреннего устройства компьютера 
и того, как выглядят программы “на самом деле”.</p>
<p>Из главы “Абстракции и виртуальные машины” читательница поймёт, что программисты — лентяи, и постоянно
используют одни и те же приёмы, чтобы облегчать себе жизнь. Просто иногда называют их по-разному. </p>
<p>В главе “Языки программирования” рассказано о том, каким образом программы, написанные людьми по специальным
правилам, превращаются в команды, которые компьютер может выполнить.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Алгоритмы"><a class="header" href="#Алгоритмы">Алгоритмы</a></h1>
<p>Алгоритм — чёткая инструкция для достижения какого-нибудь результата. Сложение и умножение чисел в столбик — алгоритм.
Рецепт (если он хороший) — алгоритм приготовления блюда. А что такое хороший рецепт?</p>
<p><strong>Хороший рецепт:</strong></p>
<blockquote>
<ol>
<li>Разогреть духовку до 210 градусов</li>
<li>Выложить на решётку чевапчичи</li>
<li>Поставить на полку противень (для сбора жира), а на него — решётку</li>
<li>Запекать 25 минут</li>
</ol>
</blockquote>
<p>А плохой?</p>
<blockquote>
<p>Жарить чевапчичи до готовности</p>
</blockquote>
<p>Каждый шаг хорошего рецепта понятен и вполне однозначен, а единственный шаг плохого рецепта содержит лишь какие-то общие указания.</p>
<p>Кроме того, хороший рецепт подразумевает, что исполнитель однозначно понимает все шаги, из которых он состоит,
и умеет их выполнять (так, как это представлял автор рецепта). Поэтому для человека, который умеет разогревать духовку, выкладывать продукты
на решётку и засекать время, <em>хороший рецепт</em> вполне будет алгоритмом.</p>
<p>Обычно алгоритмы решают целое семейство сходных задач. Например, с помощью сложения в столбик
можно сложить любые два числа, порядок действий от этого не изменится. Алгоритм “разложить в алфавитном порядке”
одинаково пригоден и для сортировки специй, и для сортировки книг.</p>
<p>Часто бывает так, что какой-нибудь более сложный алгоритм включает в качестве шага какой-то более простой. На кухне
такое, впрочем, встречается нечасто, а вот в математике — запросто. Например, чтобы перемножить два числа в столбик,
в конце придётся сложить (обычно тоже в столбик) частичные произведения.</p>
<p>Бывает так, что некоторые шаги нужно повторять до достижения определённого результата. Например, как почистить мешок картошки:</p>
<blockquote>
<ol>
<li>Если в мешке не осталось картошки, перейти к шагу 6</li>
<li>Взять картошку из мешка</li>
<li>Почистить её</li>
<li>Положить её в миску-с-чищеной-картошкой</li>
<li>Перейти к шагу 2</li>
<li>Собрать очистки</li>
</ol>
</blockquote>
<p>Шаги 2-5 этого алгоритма будут повторяться до тех пор, пока вся картошка не будет почищена.</p>
<p>Такой алгоритм можно представить в виде <em>блок-схемы</em> (на ней хорошо видно это повторение):</p>
<pre class="mermaid">flowchart TD
    Bg((Начало)) --&gt; A
    A{Есть ли в мешке\n картошка?} --&gt;|Да| B[Взять картошку из мешка]
    B --&gt; Cz[Почистить её]
    Cz --&gt; C[Положить в миску]
    C --&gt; A
    A -----&gt;|Нет| E[Собрать очистки]
    E --&gt; En((Конец))        
</pre>
<p>Бывает даже так, что какой-то алгоритм включает в качестве шага самого себя — это называется рекурсией. Правда, с этим
нужно быть аккуратным, потому что его исполнение может никогда не закончиться. Классический пример — вычисление N-ного числа Фибоначчи.
Ряд Фибоначчи начинается с двух единиц, а далее каждое следующее число равно сумме двух предшествующих:</p>
<p>\[ 1, 1, 2, 3, 5, 8, 13, 21, 34, 56… \]</p>
<p><strong>Как вычислить N-ное число Фибоначчи</strong></p>
<blockquote>
<ol>
<li>Если <code>N &lt; 1</code> — таких чисел нет. Ошибка.</li>
<li>Если <code>N = 1</code> или <code>N = 2</code> — ответ равен 1. Дальше делать ничего не надо</li>
<li>Вычислить N-1-ое число</li>
<li>Далее вычислить N-2-ое число</li>
<li>Сложить эти два числа, это и будет ответ</li>
</ol>
</blockquote>
<p>Во всех случаях алгоритмы подразумевают исполнителя, который должен понимать команды и уметь их правильно исполнять. При этом что по сути 
он собою представляет — не важно: рецепту может следовать и шеф, и поварёнок, и простая домохозяйка, а алгоритму вычисления чисел Фибоначчи
может следовать и компьютер, и человек с калькулятором. Важно только, чтобы все одинаково понимали набор команд.</p>
<p>В следующем разделе рассмотрим, что же умеет типичный исполнитель-компьютер.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-работает-компьютер"><a class="header" href="#Как-работает-компьютер">Как работает компьютер</a></h1>
<blockquote>
<p>Любая достаточно развитая технология неотличима от магии<br />
(<em>третий закон Артура Кларка</em>)</p>
</blockquote>
<p>Компьютеры умеют только одно: производить разные операции над нулями и единицами.</p>
<p>Но, во-первых, этих нулей и единиц <em>много</em> (порядка сотни миллиардов, если учитывать только оперативную память), 
а во-вторых, делают они это очень <em>быстро</em> (миллиарды операций в секунду). Поэтому нам кажется, что происходит 
какая-то магия. Эту магию мы можем увидеть, услышать или ощутить благодаря всяким дополнительным приспособлениям 
(устройствам ввода-вывода), с помощью которых вычислительная машина может взаимодействовать с внешним миром (и с нами).</p>
<p>Схематически компьютеры с момента самого их изобретения устроены следующим образом 
(эта схема называется <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0">архитектурой фон Неймана</a>):</p>
<pre class="mermaid">graph LR
    subgraph C[&quot;Процессор&quot;]
        direction LR
        M[Устройство\nуправления]
        ALU[Арифметико-логическое устройство]
        R[Регистры]:::alu
    end
    MEM
    
    C &lt;--&gt; MEM[Оперативная память]
    C &lt;--&gt; IO[Устройства\nввода-вывода]

classDef alu fill:#9ff;
</pre>
<p>Для чего нужны все эти части?</p>
<h2 id="Процессор-и-его-части"><a class="header" href="#Процессор-и-его-части">Процессор и его части</a></h2>
<p>Арифметико-логическое устройство занимается арифметикой (складывает, вычитает, умножает, делит и т.п.)
и логикой (сравнивает значения, выполняет дизъюнкцию, конъюнкцию и другие логические операции).</p>
<p>У процессора есть небольшое количество (порядка пары дюжин) <em>регистров</em>, в которых хранятся
промежуточные результаты вычислений (и сравнений) и другие важные вещи, например,
по какому адресу памяти нужно читать следующую команду.</p>
<p>Ключевая часть компьютера — устройство управления, которое командует почти всем остальным. 
Без него компьютер превратился бы в арифмометр, который работает только тогда, когда человек 
нажимает кнопки и крутит ручку. Устройство управления командует и само собой, читая из оперативной памяти команды и исполняя их.</p>
<p>Команды могут быть разными, например:</p>
<ul>
<li>Прочитать какое-нибудь значение из памяти и записать его в один из регистров</li>
<li>Сложить числа из регистров</li>
<li>Отправить какую-нибудь команду на одно из устройств вывода</li>
<li>Перейти на какой-то другой адрес и начать читать команды оттуда</li>
</ul>
<p>Собственно, последовательность таких команд и составляет программу. Сами команды, разумеется, тоже кодируются нулями и единицами.</p>
<h2 id="Память"><a class="header" href="#Память">Память</a></h2>
<p>Оперативная память (часто просто “память”) состоит из множества ячеек, каждая из которых может хранить целое число от 0 до 255.
У каждой ячейки есть свой номер — он называется адресом. В оперативной памяти хранится всё, что нужно для работы компьютера прямо сейчас. </p>
<h2 id="Устройства-ввода-и-вывода"><a class="header" href="#Устройства-ввода-и-вывода">Устройства ввода и вывода</a></h2>
<p>Устройства ввода и вывода нужны для взаимодействия компьютера с внешним миром: без этого он не сможет
делать ничего полезного. Устройства ввода, например, — это клавиатура и мышь, устройство вывода — монитор.</p>
<p><strong>NB</strong>: жёсткий диск (SSD, флешка) — это не часть оперативной памяти, а одно из устройств ввода-вывода.
Когда мы открываем какой-либо файл, то сначала процессор просит жёсткий диск скопировать данные с какого-то
определённого места диска в память, а когда сохраняем — наоборот, записать данные обратно на диск. </p>
<h2 id="Как-выглядят-программы"><a class="header" href="#Как-выглядят-программы">Как выглядят программы</a></h2>
<p>Программа может выглядеть, например, так:</p>
<ol>
<li>загрузи в регистр <code>A</code> число из памяти адресу 1</li>
<li>загрузи в регистр <code>B</code> число из памяти по адресу 2</li>
<li>сравни число из регистра <code>A</code> с числом из регистра <code>B</code></li>
<li>если первое число меньше, перейди к шагу 7</li>
<li>уменьши число в регистре <code>А</code> на число в регистре <code>B</code> (то есть в <code>A</code> будет <code>A - B</code>)</li>
<li>перейди к шагу 3</li>
<li>положи в память содержимое регистра <code>A</code> по адресу 3</li>
</ol>
<p>А <a href=" http://tpcg.io/_B2WE09" target="_blank">вот как это выглядит</a> в виде настоящей программы. Наверху есть кнопка <code>Execute</code>, 
а внизу кода можно поменять начальные значения в ячейках <code>num1</code> и <code>num2</code>.</p>
<p>Допустим, по адресу 1 расположено число 7, а по адресу 2 — число 3. Рассмотрим выполнение программы по шагам:</p>
<div class="table-wrapper"><table><thead><tr><th>Шаг</th><th>№ ком.</th><th>Команда</th><th>№ след.</th><th><code>A</code></th><th><code>B</code></th><th>Результат<br />сравнения</th></tr></thead><tbody>
<tr><td>1</td><td>1</td><td>Ячейка 1 → <code>A</code></td><td>2</td><td>7</td><td></td><td></td></tr>
<tr><td>2</td><td>2</td><td>Ячейка 2 → <code>B</code></td><td>3</td><td>7</td><td>3</td><td></td></tr>
<tr><td>3</td><td>3</td><td>Сравнить <code>A &lt; B</code></td><td>4</td><td>7</td><td>3</td><td></td></tr>
<tr><td>4</td><td>4</td><td>Если так, перейти к <strong>7</strong></td><td>5</td><td>7</td><td>3</td><td>нет</td></tr>
<tr><td>5</td><td>5</td><td><code>A - B</code> → <code>A</code></td><td>6</td><td>4</td><td>3</td><td>нет</td></tr>
<tr><td>6</td><td>6</td><td>Перейти к <strong>3</strong></td><td>3</td><td>4</td><td>3</td><td>нет</td></tr>
<tr><td>7</td><td>3</td><td>Сравнить <code>A</code> &lt; <code>B</code></td><td>4</td><td>4</td><td>3</td><td>нет</td></tr>
<tr><td>8</td><td>4</td><td>Если так, перейти к <strong>7</strong></td><td>5</td><td>4</td><td>3</td><td>нет</td></tr>
<tr><td>9</td><td>5</td><td><code>A - B</code> → <code>A</code></td><td>6</td><td>1</td><td>3</td><td>нет</td></tr>
<tr><td>10</td><td>6</td><td>Перейти к <strong>3</strong></td><td>2</td><td>1</td><td>3</td><td>нет</td></tr>
<tr><td>11</td><td>3</td><td>Сравнить <code>A &lt; B</code></td><td>4</td><td>1</td><td>3</td><td>да</td></tr>
<tr><td>12</td><td>4</td><td>Если так, перейти к <strong>7</strong></td><td>5</td><td>1</td><td>3</td><td>да</td></tr>
<tr><td>13</td><td>7</td><td><code>A</code> → Ячейка 3</td><td>(конец)</td><td>1</td><td>3</td><td>да</td></tr>
</tbody></table>
</div>
<p>В этом случае программа вычислила остаток от деления числа 7 на число 3, вычитая из одного другое до тех пор, пока это возможно.</p>
<h3 id="Контрольный-вопрос"><a class="header" href="#Контрольный-вопрос">Контрольный вопрос</a></h3>
<blockquote>
<p>Что случится, если в ячейке <code>2</code> будет записан ноль?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Абстракции-и-виртуальные-машины"><a class="header" href="#Абстракции-и-виртуальные-машины">Абстракции и виртуальные машины</a></h1>
<p>Писать программы в виде непосредственно команд для процессора весьма и весьма накладно, потому что
кроме арифметики и логики нужно заниматься вводом и выводом, а как именно это делать — зависит
буквально от всего, начиная от модели монитора и заканчивая тем, в какой именно порт воткнута клавиатура.</p>
<p>И здесь на помощь приходит идея абстрагирования. Поясним её на кулинарном примере.
Когда в рецепте написано “вскипятить воду”, совершенно безразлично, каким именно способом 
это будет происходить. Один вскипятит воду в чайнике, другой в кастрюльке,
третий в микроволновке, четвёртый на костре, пятый скомандует помощникам и т. п.
Это некая абстракция, которая специфицирует результат, но не способ его достижения.</p>
<p>И именно такие абстракции очень нужны программистам. Например: “выведи строку” (неважно, на какой экран, может, 
вообще на принтере напечатать) или “прочитай файл по такому-то пути” (на диске, на флешке, по сети и т. п.),
и нужен некий <em>уровень абстракции</em> (abstraction level), который возьмёт на себя все конкретные шаги по достижению какого-либо результата.</p>
<p>Для этого существует операционная система (ОС). Вместо того чтобы обращаться к видеокарте и монитору, программист просит ОС “напечатать на экране”,
вместо обращения к жёсткому диску — “прочитай мне файл с таким-то именем”, и так далее. Такие обращения к ОС называются 
<em>системными вызовами</em> (system call). Кроме того, операционная система позволяет писать программу, не задумываясь о том, 
что вместе с ней одновременно могут работать какие-то другие программы, и множество всего прочего.</p>
<p>Но программисты редко работают напрямую с системными вызовами. Дело в том, что даже разные версии одной ОС могут иметь 
несколько различающиеся соглашения по этому поводу, а уж у разных ОС (например, Windows и Linux) системные вызовы
совсем разные. Поэтому здесь нужен ещё один уровень абстракции, который обычно предоставляется 
средствами языка программирования, и он скрывает от программиста все тонкости взаимодействия с операционной системой.</p>
<p>Так, команда “напечатай строку на экране” в зависимости от ОС превращается в разные системные вызовы,
а в зависимости от железа ОС делает разные вещи, но обо всём этом программисту обычно думать не нужно.</p>
<p>Но чтобы что-нибудь вычислить, операционная система не нужна, и в этом случае язык программирования 
помогает абстрагироваться от конкретных арифметических команд конкретного процессора.</p>
<h2 id="Виртуальные-машины"><a class="header" href="#Виртуальные-машины">Виртуальные машины</a></h2>
<p>Идея абстрагирования имеет и другие интересные применения. Например, если очень хочется запустить какую-нибудь
программу, написанную для отсутствующей аппаратной системы (например, Sega), то достаточно написать эмулятор, который будет
исполнять команды точно так же, создав таким образом <em>виртуальную машину</em> (приставка — тоже машина).</p>
<p>Но кто сказал, что виртуальная машина должна обязательно соответствовать какой-то существующей системе? 
Можно ведь придумать свой удобный набор команд (“байт-код”), а затем реализовать его эмуляторы для всех нужных систем.</p>
<p>Именно так работает Java: программы на ней распространяются в виде кода для специальной 
виртуальной машины (Java Virtual Machine, JVM), а для каждой целевой системы существуют реализации JVM.
Более того, есть несколько альтернативных реализаций JVM. А ещё на базе JVM можно писать программы не только на 
Java, но и на других языках.</p>
<p>Поскольку к этому моменту уже ничего не понятно, нарисуем древо абстракций:</p>
<pre class="mermaid">flowchart TD
    subgraph Lang[Языки программирования]
        Java
        Groovy
        Kotlin    
    end
    Lang &lt;--&gt;|Байт-код| JVM
    subgraph JVM[Виртуальные машины Java]
        Or[Oracle JVM]
        OpenJDK    
    end
    JVM &lt;--&gt;|Системные вызовы| OS
    subgraph OS[Операционные системы]
        Windows
        Linux
        macOS
    end
    OS &lt;--&gt;|Машинный код| Proc
    JVM &lt;--&gt;|Машинный код| Proc
    subgraph Proc[Процессоры]
        Intel
        AMD
        ARM[Apple Silicon]
    end
</pre>
<p>Как это понимать?</p>
<p>Программу, написанную на любом из этих языков, может выполнить любая виртуальная машина Java. Она, в свою очередь,
может работать на разных операционных системах, которые могут работать на разном оборудовании. И благодаря тому,
что на каждом уровне правила строго определены, большую часть времени программисту вообще не нужно думать, 
как это работает на самом деле.</p>
<h2 id="Глубже-и-выше"><a class="header" href="#Глубже-и-выше">Глубже и выше</a></h2>
<p>Древо можно наращивать в обоих направлениях. Если речь идёт о программировании хоть сколько-нибудь сложной системы,
то программисты сами наращивают абстракции. Например, брать деньги за какую-нибудь услугу можно разными способами,
но с точки зрения процесса купли-продажи способ неважен, поэтому этот процесс прячется за абстракцией “платежа”.</p>
<p>Более изощрённый пример: существует, например, Jython — реализация языка Python, написанная на Java. 
А на Python написан эмулятор <a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%B7%D0%BE%D1%82%D0%B5%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">эзотерического</a>
языка программирования <a href="https://ru.wikipedia.org/wiki/Befunge">Befunge</a>.
Но это уже из области ненормального программирования.</p>
<p>С другой стороны, можно запускать программы не на реальной, а на виртуальной машине. Но всё обстоит даже интереснее:
многие “реальные” современные процессоры содержат внутри специальную программу (<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%B4">микрокод</a>),
которая на самом деле исполняет “в железе” все команды.</p>
<p>Ну и в самом железе есть ещё пара уровней абстракции, которые скрывают от разработчиков логических схем процессора реальные 
физические явления. И всё это как-то работает!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Языки-программирования"><a class="header" href="#Языки-программирования">Языки программирования</a></h1>
<p>Сосредоточимся теперь на языках программирования. Они позволяют писать программы на более “человеческом” языке. 
Затем с помощью специальной программы  то, что написано в “человечьем” виде превращается в команды для машины.
Выглядит это так:</p>
<pre class="mermaid">flowchart LR
    s[&quot;Исходный код \n(на языке программирования)&quot;]
    t{Транслятор}
    c[&quot;Команды для процессора \n(машинный код)&quot;]
    
    s --&gt; t --&gt; c
    
    style t fill:#fe3
</pre>
<p><em>Исходный код</em> — текст, написанный по специальным правилам языка программирования. <em>Транслятор</em> “переводит”
его с языка программирования в последовательность команд для процессора (<em>машинный код</em>) или для виртуальной машины (<em>байт-код</em>).</p>
<p>Детали работы транслятора сейчас совершенно не важны. Важно, что делать это можно двумя разными способами:
или один раз заранее, или каждый раз при запуске программы.</p>
<h2 id="Виды-трансляции"><a class="header" href="#Виды-трансляции">Виды трансляции</a></h2>
<h3 id="Компиляция"><a class="header" href="#Компиляция">Компиляция</a></h3>
<p><em>Компиляция</em> — преобразование исходного кода в машинный <em>заранее</em>. Это происходит, как правило,
на компьютере разработчика, и, таким образом, пользователь не имеет доступа к исходному коду программы (и без специальных
навыков ему очень сложно что-то там подкрутить).</p>
<h3 id="Интерпретация"><a class="header" href="#Интерпретация">Интерпретация</a></h3>
<p><em>Интерпретация</em> — преобразование исходного кода в машинный прямо в процессе работы программы. Поэтому для работы программы
каждый раз нужен <em>интерпретатор</em>. Из-за того, что трансляция происходит каждый раз во время работы программы, оно в целом
работает медленнее, чем в случае компиляции. Зато программисту нужно гораздо меньше думать о том, на какой именно системе
будет работать его программа. </p>
<p>Виртуальные машины размывают грань между интерпретацией и компиляций. Например, традиционно считается, что язык
Java — компилируемый, а Python — интерпретируемый. На самом деле, оба они основаны на виртуальных машинах, вот
только в случае Java виртуальная машина существует и распространяется отдельно от транслятора, а в случае Python они объединены.</p>
<p>Компилируемые языки обычно в целом более строгие и требовательные к программисту (потому что программу нужно скомпилировать
“раз и навсегда”), а интерпретируемые отличаются большей гибкостью.</p>
<h2 id="repl"><a class="header" href="#repl">REPL</a></h2>
<p>Интерпретируемые языки обычно содержат так называемый REPL — Read-Eval-Print Loop. Это специальная
программа, которая читает (read) с клавиатуры какую-нибудь очередную команду языка программирования, сразу же исполняет (evaluate) её
и выводит (print) результат. Потом процесс повторяется заново. Это очень удобно для того, чтобы разобраться в чём-нибудь,
например, в процессе обучения.</p>
<p>В дистрибутиве Python есть специальный инструмент — IPython, который как раз реализует эту парадигму. Осталось его запустить и читать следующий раздел.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Давай-сыграем-в-игру"><a class="header" href="#Давай-сыграем-в-игру">Давай сыграем в игру</a></h1>
<p>Есть такая простая игра, которую можно сыграть с детьми (и с компьютерами). Она называется “Угадай число”. Правила игры такие:</p>
<ol>
<li>Один игрок загадывает число от 1 до 100.</li>
<li>Второй игрок пытается угадать это число.</li>
<li>После каждой попытки первый игрок говорит, больше или меньше загаданное число, чем предложенное.</li>
<li>Второй игрок делает следующую попытку, и так до тех пор, пока число не будет угадано.</li>
</ol>
<p>Можно сыграть в эту игру с компьютером, причём компьютер может быть как первым, так и вторым игроком. Давайте напишем программу, которая будет играть в эту игру с нами
(компьютер будет первым игроком, а мы — вторым).</p>
<h2 id="Что-нужно-делать-компьютеру"><a class="header" href="#Что-нужно-делать-компьютеру">Что нужно делать компьютеру</a></h2>
<ol>
<li>Загадать число от 1 до 100.</li>
<li>Вывести “Угадай число от 1 до 100”.</li>
<li>Спросить у пользователя число.</li>
<li>Если число равно загаданному, то вывести “Ты угадал!” и закончить игру.</li>
<li>Если число больше загаданного, то вывести “Загаданное число меньше”.</li>
<li>Если число меньше загаданного, то вывести “Загаданное число больше”.</li>
<li>Перейти к шагу 3.</li>
</ol>
<h2 id="Как-это-сделать"><a class="header" href="#Как-это-сделать">Как это сделать</a></h2>
<p>В этом алгоритме есть несколько разных типов действий:</p>
<ol>
<li>Вывести текст на экран.</li>
<li>Спросить у пользователя число.</li>
<li>Сравнить два числа.</li>
<li>Сгенерировать случайное число.</li>
<li>Повторять действия</li>
</ol>
<p>На самом деле есть ещё несколько тонких моментов, которые в будущем нужно предусмотреть. Например, как быть, если пользователь — кот, у него лапки, и он вводит “неешь меня”?</p>
<h2 id="Процесс-изучения"><a class="header" href="#Процесс-изучения">Процесс изучения</a></h2>
<p>Сначала попробуем освоить каджое действие в отдельности, и в этом нам поможет IPython. Потом соберём всё вместе и напишем программу.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-выглядит-ipython"><a class="header" href="#Как-выглядит-ipython">Как выглядит IPython</a></h1>
<p>IPython (Interactive Python) — отличный инструмент для обучения, быстрой проверки чего-нибудь и т. п.
Он напоминает песочницу, в которой можно поиграть с языком Python, не боясь сломать что-нибудь важное.
При запуске он выглядит как-то так:</p>
<p><img src="images/01_00_00_ipython.png" alt="IPython при запуске" /></p>
<p>и приветливо ожидает ввода команд (надпись <code>In [1]:</code> называется <code>prompt</code> — приглашением).</p>
<p>Сверху написана всякая служебная информация, из которых главное — версия Python (на скриншоте — 3.8.8).</p>
<p>Здесь же следует сделать лирическое отступление и рассказать немного о чёрном (или белом) окошке с буквами,
которое именуется эмулятором терминала или же просто терминалом.</p>
<blockquote>
<p>Исторически терминал — это клавиатура-с-монитором (а ещё раньше — клавиатура-с-принтером). К большой ЭВМ,
которая могла занимать целый машинный зал, были присоединены одно или несколько таких устройств, и несколько
пользователей могли работать одновременно, не мешая друг другу. С точки зрения ЭВМ это устройство ввода-вывода,
которое умеет вводить и выводить текст. Изначально они были монохромные (точнее, чёрно-зелёные и чёрно-оранжевые),
а уже много позже обрели целых 16 цветов.</p>
<p>Эта концепция оказалась настолько живучей, что в любом современном компьютере есть эмулятор терминала, который
обеспечивает возможность взаимодействовать с компьютером с помощью текста.</p>
</blockquote>
<p>IPython ждёт, что пользователь введёт строку кода на Python, тогда выполнит её, выведет результат исполнения
и будет ждать следующую строку.</p>
<p>Нажимая кнопки <code>↑</code> и <code>↓</code> можно перемещаться по истории ввода, а кнопками <code>←</code> и <code>→</code> — перемещаться по строке.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вывод-текста-на-экран"><a class="header" href="#Вывод-текста-на-экран">Вывод текста на экран</a></h1>
<p>Поскольку вывод текста сначала происходил не на экран, а на бумагу, то для вывода текста исторически используется слово <code>print</code> (печать).
Воздадим должное программистским традициям, напечатав на экране <code>&quot;Hello, world!&quot;</code>.</p>
<p>Открыв IPython, нужно в ответ на приглашение ввести <code>print(&quot;Hello, world!&quot;)</code> и нажать <code>Enter</code>.</p>
<p>Произошла какая-то магия и текст “Hello, world!” появился на экране. Вжух!</p>
<p>Можно попробовать сделать это ещё раз с другим текстом, например, <code>print(&quot;Привет, мир!&quot;)</code> или <code>print(&quot;Я не хлеб а код, неешь подумой!&quot;)</code>.</p>
<p>Главное, чтобы внутри скобок был текст в кавычках, и в этом тексте не было внутренних кавычек.</p>
<h2 id="Как-это-работает"><a class="header" href="#Как-это-работает">Как это работает</a></h2>
<p>Каждая строка в IPython — это команда, которую IPython выполняет. Команды могут быть разных типов. Конструкция <code>print(&quot;Hello, world!&quot;)</code> — это вызов подпрограммы. Сначала разберёмся, что такое подпрограмма, потом разберёмся, как её можно вызвать (то есть запустить).</p>
<h3 id="Подпрограммы-функции"><a class="header" href="#Подпрограммы-функции">Подпрограммы (функции)</a></h3>
<p>Подпрограммы (они же часто называются функциями) — вещь удивительно полезная в хозяйстве. Один раз запрограммировал какое-то действие, возможно даже не ты, а кто-то другой, а потом можешь вызывать это действие в любой момент, когда понадобится. Мало того, у многих таких действий есть ещё и настраиваемые параметры (называемые аргументами), которые можно менять. </p>
<h3 id="Вызов-функции"><a class="header" href="#Вызов-функции">Вызов функции</a></h3>
<p>Зачем нужны все эти скобочки, кавычки и прочая орфография? Давайте разберём пример <code>print(&quot;Hello, world!&quot;)</code> по частям.</p>
<p><code>print</code> — это имя функции, которая встроена в Python, она есть везде и всегда.</p>
<p>Чтобы её вызвать, нужно поставить после её имени пару круглых скобок: <code>print()</code>. Эту нотацию программисты своровали у математиков: когда в математике пишут \( f(x) \), это означает, что нужно взять функцию \( f \) и применить её к аргументу \( x \). В нашем случае <code>print</code> — это функция, а <code>&quot;Hello, world!&quot;</code> — это аргумент.</p>
<p>Кстати, можно попробовать вызвать функцию <code>print</code> без аргумента, то есть просто написать <code>print()</code>. Что произойдёт? Попробуйте!</p>
<h3 id="Аргументы-функции-print"><a class="header" href="#Аргументы-функции-print">Аргументы функции <code>print</code></a></h3>
<p>Аргументы функции — это просто значения, которые передаются в функцию. В нашем случае единственный аргумент — строка <code>&quot;Hello, world!&quot;</code>. Строка — это просто какой-то текст, заключённый в кавычки. В Python используются одинарные и двойные кавычки. Можно использовать любые, но важно, чтобы открывающая кавычка и закрывающая были одного типа.</p>
<p>Если аргументов несколько, то они отделяются запятой.</p>
<h3 id="Что-мы-можем-написать-для-нашей-программы"><a class="header" href="#Что-мы-можем-написать-для-нашей-программы">Что мы можем написать для нашей программы</a></h3>
<p>Первой строкой нашей программы для игры будет вывод текста на экран. Выводить текст на экран мы будем с помощью функции <code>print</code>. В качестве аргумента мы будем передавать строку, которую нужно вывести на экран. Вот так:</p>
<pre><code class="language-python">print(&quot;Угадай число от 1 до 100&quot;)
</code></pre>
<h1 id="Задания"><a class="header" href="#Задания">Задания</a></h1>
<ol>
<li>Вызвать функцию <code>print</code> без аргумента. Что произойдёт? Напечатано ли что-нибудь?</li>
<li>Вызвать функцию <code>print</code> с одним аргументом-строкой, но забыть закрыть кавычки. Что произойдёт?</li>
<li>Вызвать функцию <code>print</code> с двумя, тремя или большим количеством аргументов (аргументы отделяются друг от друга запятой). Что произойдёт?</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ipython---калькулятор-на-стероидах"><a class="header" href="#ipython---калькулятор-на-стероидах">IPython - калькулятор на стероидах</a></h1>
<p>IPython умеет не только вызывать функцию <code>print</code>, но и вычислять арифметические выражения. Для этого нужно ввести выражение и нажать <code>Enter</code>.</p>
<blockquote>
<p><strong>NB:</strong> Когда мы развлекались с печатью текста, вывод IPython выглядел так:</p>
<pre><code class="language-ipython">In [1]: print(&quot;Hello, world!&quot;)
Hello, world!
</code></pre>
<p>Если же мы будем использовать IPython в качестве калькулятора, то вывод будет выглядеть так:</p>
<pre><code class="language-ipython">In [1]: 2 + 2
Out[1]: 4
</code></pre>
<p>Обратите внимание на эту разницу. В первом случае мы вызвали функцию, которая что-то печатает на экране.
Во втором случае мы просто ввели выражение, и IPython напечатал для нас его результат.</p>
</blockquote>
<p>Выражения могут состоять из одного числа, например, <code>2</code> (в ответ будет выведено <code>2</code>).</p>
<p>Можно посчитать что-нибудь посложнее, например, умножить пару больших чисел, например, ввести что-то в духе <code>1111 * 2222</code> и нажать <code>Enter</code>. Тут же появится ответ.</p>
<p>Кроме умножения, числа можно складывать (<code>19 + 23</code>), вычитать (<code>15 - 167</code>), делить (<code>10 / 2</code>) и возводить в степень (<code>2 ** 16</code>).</p>
<p>Python умеет обрабатывать очень большие целые числа (например, <code>2 ** 1000</code> или даже <code>2 ** 122910</code> — в нём 37 тыс. десятичных знаков).</p>
<p>Скобки и приоритет операций работают так, как мы привыкли. Можно попробовать вычислить <code>2 + 2 * 2</code>.</p>
<h2 id="Сравнение-чисел"><a class="header" href="#Сравнение-чисел">Сравнение чисел</a></h2>
<p>Нам ведь нужно сравнивать число, которое ввёл пользователь, с тем, которое загадал компьютер. Для этого есть специальные операторы сравнения. Всего их шесть:</p>
<ol>
<li><code>&lt;</code> — меньше</li>
<li><code>&gt;</code> — больше</li>
<li><code>&lt;=</code> — меньше или равно</li>
<li><code>&gt;=</code> — больше или равно</li>
<li><code>==</code> — равно</li>
<li><code>!=</code> — не равно</li>
</ol>
<p>Первые два не вызывают никаких вопросов, вторые два выглядят несколько непривычно (вместо <code>≤</code> и <code>≥</code>, которых нет на стандартной клавиатуре), но всё равно понятно, а вот последние два вызывают вопросы. Почему два знака равенства, а не один? Почему неравенство обозначается так странно?</p>
<p>Дело в том, что один знак равенства (<code>=</code>) служит практически во всех языках программирования не для того, чтобы сравнивать числа, а совсем для другого (об этом позже). Поэтому во избежание путаницы в Python, как и во многих других языках, для сравнения чисел используется два знака равенства.</p>
<p>Оператор <code>!=</code> — это попытка изобразить знак неравенства, который в математике обозначается как <code>≠</code> (его тоже нет на стандартной клавиатуре). Некоторые другие языки изображают его иными способами, но в Python используется вариант <code>!=</code>, как и в подавляющем большинстве других языков.</p>
<p>Итак, попробуем что-нибудь сравнить:</p>
<pre><code class="language-ipython">In [1]: 2 &lt; 3
Out[1]: True

In [2]: 2 * 2 == 5
Out[2]: False
</code></pre>
<p>Слова <code>True</code> и <code>False</code> обозначают, соответственно, Истину и Ложь (именно так, с больших букв). </p>
<h2 id="Ошибки"><a class="header" href="#Ошибки">Ошибки</a></h2>
<p>Если написать выражение, не соответствующее правилам Python, например, <code>2 - </code> или <code> * 7</code>, то интерпретатор будет
ругаться. Ошибка выглядит следующим образом:</p>
<pre><code>File &quot;&lt;ipython-input-1-12edae092881&gt;&quot;, line 1
    2 -
       ^
SyntaxError: invalid syntax
</code></pre>
<p>Строку про файл мы можем игнорировать, потому что код исполняется в интерактивном окружении, а вот ниже информация полезная.
Сначала приведена строка кода, в которой содержится ошибка, на строку ниже стоит символ <code>^</code>, который словно стрелка указывает на 
место, где возникла ошибка, а ещё ниже указан тип ошибки (<code>SyntaxError</code>) и описание (неверный синтаксис).</p>
<h1 id="Задания-1"><a class="header" href="#Задания-1">Задания</a></h1>
<ol>
<li>Посчитайте, сколько секунд в сутках.</li>
<li>Напечатать числа с помощью функции <code>print</code> и с помощью выражений. Почему вывод отличается?</li>
<li>Напечатать какие-нибудь числа и строки с помощью одного вызова функции <code>print</code>. Какой вывод получается?</li>
<li>Напечатать текст вида “Количество секунд в году: ….”, где вместо многоточия будет правильное число с помощью одного вызова функции <code>print</code>. </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типы-данных"><a class="header" href="#Типы-данных">Типы данных</a></h1>
<p>А теперь немного скучной (но важной) теории. Все значения, с которыми мы имеем дело в программировании, имеют
определённый <em>тип</em>. Это необходимо для того, чтобы нули и единицы имели какое-то определённое значение.</p>
<p>Узнать, какого типа выражение можно с помощью функции <code>type</code>. Она принимает в качестве аргумента выражение и возвращает его тип. Например:</p>
<pre><code class="language-ipython">In [1]: type(5)
Out[1]: int

In [2]: type(3.1415926)
Out[2]: float

In [3]: type(&quot;Hello, world!&quot;
Out[3]: str

In [4]: type(True)
Out[4]: bool
</code></pre>
<p><code>int</code> — целочисленный тип, <code>float</code> — вещественное (не обязательно целое) число, <code>str</code> — строковый тип, <code>bool</code> — логический (булевый).</p>
<p>Существуют и другие встроенные типы данных, но для нашей маленькой игры нам понадобятся только эти четыре.</p>
<p>Типы данных ограничивают набор возможных действий, которые можно совершать с этими данными. Например, можно сложить два числа, а сложить число и строку нельзя.</p>
<pre><code class="language-ipython">In [4]: 5 + 7
Out[4]: 12

In [5]: 7 + 3.1415926
Out[5]: 10.1415926

In [6]: 5 + &quot;мешок картошки&quot;
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-6-0b2b2b0b2b2b&gt; in &lt;module&gt;()
----&gt; 1 5 + &quot;мешок картошки&quot;

TypeError: unsupported operand type(s) for +: 'int' and 'str'
</code></pre>
<p>Уже знакомое нам сообщение об ошибке, которое говорит, что операция <code>+</code> не определена для типов <code>int</code> и <code>str</code>, то есть складывать 5 и “мешок картошки” нельзя.
Более того, если мы попробуем сложить число 5 и строку “7”, то ошибка будет та же.</p>
<p>При этом второе выражение вычисляется без ошибок, так как Python автоматически преобразует целое число в вещественное, чтобы совершить операцию сложения.</p>
<p>С другой стороны, можно попробовать сложить две строки: </p>
<pre><code class="language-ipython">In [6]: &quot;5&quot; + &quot;7&quot;
Out[6]: &quot;57&quot;
</code></pre>
<h2 id="Явное-преобразование-типов"><a class="header" href="#Явное-преобразование-типов">Явное преобразование типов</a></h2>
<p>Часто бывает нужно превращать одни типы в другие. Для этого можно вызвать имя типа как функцию, передав в качестве аргумента то, что нужно преобразовать. Например, чтобы превратить что угодно в строку, нужно вызвать функцию <code>str</code>:</p>
<pre><code class="language-ipython">In [7]: str(5)
Out[7]: '5'

In [8]: str(True)
Out[8]: 'True'
</code></pre>
<p>Преобразование в целое число осуществляется функцией <code>int</code>:</p>
<pre><code class="language-ipython">In [9]: int(3.1415926)
Out[9]: 3

In [10]: int(&quot;5&quot;)
Out[10]: 5
</code></pre>
<p>При этом преобразование строки в число возможно только в том случае, если строка содержит только цифры. Если в строке есть что-то ещё, то произойдёт ошибка:</p>
<pre><code class="language-ipython">In [11]: int(&quot;мешок картошки&quot;)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-11-119192f62ea1&gt; in &lt;module&gt;
----&gt; 1 int(&quot;мешок картошки&quot;)

ValueError: invalid literal for int() with base 10: 'мешок картошки'
</code></pre>
<h1 id="Задачи"><a class="header" href="#Задачи">Задачи</a></h1>
<ol>
<li>Какого типа результат вычисления выражения <code>2 * 5</code>?</li>
<li>Какого типа результат вычисления выражения <code>2 / 5</code>?</li>
<li>Какие значения при приведении к логическому типу <code>bool</code> дают <code>True</code>, а какие — <code>False</code>? Можно экспериментировать с разными числами и строками.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Переменные"><a class="header" href="#Переменные">Переменные</a></h1>
<p>Переменные — важнейшая концепция языков программирования. Понятие о переменных перешло в программирование из математики, но здесь имеет несколько иной смысл. Переменные позволяют хранить данные в памяти компьютера и обращаться к ним по имени. Переменную можно представить как коробку с подписью, в которую можно положить что-то и взять оттуда. Для нашей маленькой игры нам понадобятся переменные для хранения загаданного числа и предположения игрока.</p>
<p>В Python переменные создаются с помощью операцией, называемой по-русски <em>присваивание</em> (довольно странный перевод слова assignment). В этой операции есть две части: слева — имя переменной, а справа — значение, которое будет храниться в переменной. Между ними стоит знак <code>=</code>. Например, в следующем примере создаётся переменная <code>answer</code> и в неё записывается значение <code>42</code>:</p>
<pre><code class="language-ipython">In [1]: answer = 42
</code></pre>
<p>Интерпретировать это можно следующим образом: “сделай коробку с надписью <code>answer</code> и положи в неё число <code>42</code>”.</p>
<p>Как мы помним, если в IPython ввести выражение, то оно будет вычислено и результат будет выведен на экран. Попробуем ввести имя переменной:</p>
<pre><code class="language-ipython">In [2]: answer
Out[2]: 42
</code></pre>
<p>Если попробовать ввести имя переменной, которой ещё нет, то IPython выдаст ошибку:</p>
<pre><code class="language-ipython">In [3]: question
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-3-0b2b2b0b2b2b&gt; in &lt;module&gt;()
----&gt; 1 question

NameError: name 'question' is not defined
</code></pre>
<p>Переменные можно использовать почти во всех тех же местах, где и литералы (то есть числа, строки и др., записанные прямо в коде). Например:</p>
<pre><code class="language-ipython">In [4]: 42 ** 2 - 42 * 17
Out[4]: 1050

In [5]: answer ** 2 - answer * 17
Out[5]: 1050
</code></pre>
<p>Имя переменной должно начинаться с буквы (a-z, A-Z) или символа подчёркивания <code>_</code>. Остальные символы могут быть буквами, цифрами или символом подчёркивания. Имя переменной не должно быть в <a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">списке ключевых слов</a>, которые имеют специальное значение.</p>
<p>Если присвоить переменной новое значение, то старое значение будет забыто:</p>
<pre><code class="language-ipython">In [6]: question = &quot;Главный вселенной, жизни и всего такого: ...&quot;

In [7]: question = &quot;Сколько будет 6 х 9?&quot;

In [8]: question
Out[8]: 'Сколько будет 6 х 9?'
</code></pre>
<p>Если справа от оператора присваивания (<code>=</code>) стоит выражение, то сначала оно вычисляется, а затем результат присваивается переменной.
Поэтому можно присваивать переменной результат вычисления выражения, содержащего её самою:</p>
<pre><code class="language-ipython">In [9]: x = 42

In [10]: x = x + 1

In [11]: x
Out[11]: 43
</code></pre>
<h2 id="Типы-переменных"><a class="header" href="#Типы-переменных">Типы переменных</a></h2>
<p>Типы переменных могут меняться, если присвоить им значение другого типа. Например, в следующем примере переменная <code>x</code> сначала имеет тип <code>int</code> (целое число), а затем становится типа <code>str</code> (строка):</p>
<pre><code class="language-ipython">In [12]: x = 42

In [13]: type(x)
Out[13]: int

In [14]: x = str(x)

In [15]: type(x)
Out[15]: str
</code></pre>
<h2 id="Для-чего-полезны-переменные"><a class="header" href="#Для-чего-полезны-переменные">Для чего полезны переменные</a></h2>
<p>Переменные полезны для того, чтобы отделять собственно вычисления от данных, с которыми они работают. Например, в следующем примере мы вычисляем площадь квадрата, используя переменную <code>side</code> для хранения длины стороны:</p>
<pre><code class="language-ipython">In [16]: side = 42

In [17]: print(&quot;Площадь квадрата со стороной&quot;, side, &quot;равна&quot;, side ** 2)
Площадь квадрата со стороной 42 равна 1764

In [18]: side = 101

In [19]: print(&quot;Площадь квадрата со стороной&quot;, side, &quot;равна&quot;, side ** 2)
Площадь квадрата со стороной 101 равна 10201
</code></pre>
<p>Обратите внимание, что вызов функции <code>print</code> выглядит так же, как и в первый раз.</p>
<h1 id="Творческое-задание"><a class="header" href="#Творческое-задание">Творческое задание</a></h1>
<p>Ваш начальник хочет, чтобы программа для вывода “Hello, world!” была универсальна и расширяема. Для этого он предлагает хранить первую часть приветствия в одной переменной (как здороваться), вторую часть — в другой переменной (с кем здороваться), а затем выводить их на экран (вспомните о сложении строк). Напишите в IPython несколько команд, которые присвоят этим двум переменным правильные значения. Придумайте имена переменных, которые впечатлят вашего начальника. Попробуйте присвоить им другие значения (не <code>Hello</code> и не <code>World</code>). Придумайте весёлую кличку для начальника и поприветствуйте его.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
